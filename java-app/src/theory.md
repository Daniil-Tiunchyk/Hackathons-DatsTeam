# Проект автоматической стратегии для хакатона DatsCity

## Описание игры и цели

**DatsCity** – это онлайн-игра (геймтон) от DatsTeam, где участники строят башни из слов в трехмерном пространстве.
Игровое поле представляет собой сетку размером 30×30 по горизонтали и до 100 единиц в
высоту ([openapi.yml](file://file-EqgpUPnpFmazNzc9qFuQue#:~:text=mapSize%3A%20example%3A%20,type%3A%20integer%20type%3A%20array%20nextTurnSec)).
Башня строится путем размещения слов (набор символов) как блоков на этой сетке. При этом нужно соблюдать **правила
валидности конструкции**: слова не должны пересекаться друг с другом в пространстве (недопустимо, чтобы две буквы разных
слов занимали одну клетку), каждое новое слово должно опираться на основание – либо на землю (z=0), либо на уже
выложенные буквы снизу (чтобы не “висеть в воздухе”), и башня должна достигать минимальной высоты для получения очков.

Игра проходит в формате раундов и ходов. **Раунд** – это ограниченный промежуток времени (например, весь период
хакатона), разбитый на последовательность ходов. **Ход** длится 60
секунд ([openapi.yml](file://file-EqgpUPnpFmazNzc9qFuQue#:~:text=type%3A%20array%20nextTurnSec%3A%20type%3A%20integer,shuffleLeft%3A%20type%3A%20integer%20example%3A%203));
за этот срок стратегия игрока должна принять решение и выполнить действия. В каждом ходе сервер предоставляет актуальные
данные через API и ожидает от клиента (стратегии) ответное действие. Цель участника – автоматизировать процесс
строительства так, чтобы возвести максимально ценные башни и заработать больше всех очков, тем самым выиграв хакатон.

**Система подсчета очков:** Для каждой завершенной башни вычисляется базовый балл как сумма очков всех ее этажей (
условно, сумма значений слов или букв на каждом уровне). Этот базовый балл затем умножается на три коэффициента:

- **Коэффициент плотности** – поощряет плотную застройку этажей без больших пустот.
- **Коэффициент пропорций** – отражает сбалансированность формы башни (например, стабильность и равномерность ширины по
  высоте).
- **Коэффициент высоты** – награждает за достижение большей высоты конструкции.

Таким образом, оптимальная стратегия должна не только использовать как можно больше слов (чтобы набрать базовые очки),
но и располагать их так, чтобы башня была достаточно плотной, пропорциональной и высокой одновременно.

## Требования к решению

Исходя из условий хакатона DatsCity, решение (бот-стратегия) должно удовлетворять следующим ключевым требованиям:

- **Раунды и ходы:** стратегия работает в режиме реального времени. Каждый ход длится ~60 секунд, за которые необходимо
  проанализировать состояние и отправить ход. Решения должны приниматься быстро (в пределах этого времени), без
  промедлений, иначе ход будет потерян. После окончания раунда башни фиксируются, и начинается следующий раунд (если
  предусмотрено несколько
  раундов) ([openapi.yml](file://file-EqgpUPnpFmazNzc9qFuQue#:~:text=example%3A%20,components%2Fschemas%2Fgame.RoundResponse%27%20game.RoundResponse)) ([openapi.yml](file://file-EqgpUPnpFmazNzc9qFuQue#:~:text=properties%3A%20duration%3A%20type%3A%20integer%20example%3A,60%20endAt)).

- **Доступ к API:** для взаимодействия с игрой предоставлен HTTP API (OpenAPI спецификация). На каждом ходу можно
  вызывать следующие методы:
    - `GET /api/words` – получить текущий список доступных слов и информацию о ходе (номер хода, время до следующего,
      оставшиеся перетасовки и
      пр.) ([openapi.yml](file://file-EqgpUPnpFmazNzc9qFuQue#:~:text=summary%3A%20Words%20list%20responses%3A%20,description%3A%20OK)).
      Слова представлены списком строк, им присваиваются индексы.
    - `POST /api/build` – отправить на сервер действие строительства: список выбранных слов с указанием их индексов,
      координат позиционирования и ориентации, а также флаг окончания башни (
      done) ([openapi.yml](file://file-EqgpUPnpFmazNzc9qFuQue#:~:text=match%20at%20L36%20summary%3A%20,requestBody)).
      Если флаг `done=true`, башня считается завершенной, сохраняется, и игрок может начать новую
      башню ([openapi.yml](file://file-EqgpUPnpFmazNzc9qFuQue#:~:text=match%20at%20L36%20summary%3A%20,requestBody)).
    - `POST /api/shuffle` – запросить новый набор слов вместо текущего списка (ограниченное число раз за
      раунд) ([openapi.yml](file://file-EqgpUPnpFmazNzc9qFuQue#:~:text=summary%3A%20Shuffle%20words%20list%20responses%3A,description%3A%20OK)).
      Это можно использовать, если текущие слова неудобны; после shuffle сервер вернет обновленный список
      слов ([openapi.yml](file://file-EqgpUPnpFmazNzc9qFuQue#:~:text=responses%3A%20,components%2Fschemas%2Fmodel.PlayerWordsResponse%27%20%22400)) ([openapi.yml](file://file-EqgpUPnpFmazNzc9qFuQue#:~:text=properties%3A%20shuffleLeft%3A%20type%3A%20integer%20example%3A,word2)).
    - `GET /api/towers` – получить информацию о прогрессе: текущая строящаяся башня (если есть) и уже завершенные башни
      игрока с их
      очками ([openapi.yml](file://file-EqgpUPnpFmazNzc9qFuQue#:~:text=match%20at%20L86%20summary%3A%20All,description%3A%20OK)).
    - `GET /api/rounds` – узнать расписание раундов, время начала/окончания текущего раунда и т.д. (полезно, чтобы
      определить, сколько времени осталось до конца
      игры) ([openapi.yml](file://file-EqgpUPnpFmazNzc9qFuQue#:~:text=match%20at%20L106%20summary%3A%20game,description%3A%20OK)).

  Все запросы требуют аутентификации (ключ API в заголовке
  `X-Auth-Token`) ([openapi.yml](file://file-EqgpUPnpFmazNzc9qFuQue#:~:text=ApiKeyAuth%3A%20type%3A%20apiKey%20name%3A%20X,version%3A%20%222.0)).
  Сервис предоставляет два базовых URL – тестовый и боевой
  серверы ([openapi.yml](file://file-EqgpUPnpFmazNzc9qFuQue#:~:text=,dev%20description%3A%20Production%20server)). Наше
  решение должно поддерживать переключение между ними (например, флагом командной строки), чтобы мы могли отладить
  стратегию на тестовом сервере, а затем без изменений кода подключиться к основному серверу хакатона.

- **Правила размещения слов (валидация башни):** При строительстве нужно строго соблюдать ограничения:
    - **Геометрические ограничения:** слово можно разместить по горизонтали вдоль оси X или Y (две ориентации: например,
      `dir=0` – вдоль X, `dir=1` – вдоль Y). Каждое слово занимает последовательные клетки на одном уровне `z` (
      например, слово длиной L, положенное горизонтально, занимает L клеток подряд вдоль X на фиксированных координатах
      `y` и `z`). Координата `pos` для слова указывает его начальную (минимальную) точку
      `(x, y, z)` ([openapi.yml](file://file-EqgpUPnpFmazNzc9qFuQue#:~:text=dir%3A%20type%3A%20integer%20example%3A%201,0)) ([openapi.yml](file://file-EqgpUPnpFmazNzc9qFuQue#:~:text=properties%3A%20dir%3A%20type%3A%20integer%20example%3A,0%20pos%3A%20type%3A%20array%20example)).
      Все клетки слова должны лежать внутри границ 0≤x<30, 0≤y<30, 0≤z<100.
    - **Отсутствие пересечений:** два слова не могут занимать одну и ту же клетку пространства. При добавлении нового
      слова необходимо проверить, что все его предполагаемые координаты свободны (не заняты ранее размещенными буквами).
      Также слова не должны “перекрещиваться” на одном уровне: пересечение путей слов недопустимо, даже если буквы
      разные (каждая клетка может содержать только одну букву).
    - **Поддержка снизу:** кроме слов, лежащих на земле (`z=0`), каждое новое слово на уровне `z>0` должно быть оперто
      на слово(-а) уровнем ниже. Это означает, что для каждой клетки (буквы) слова на высоте z должна существовать
      клетка на координатах `(x, y, z-1)`, занятая частью уже размещенного слова. Иначе говоря, слово не может “висеть в
      воздухе”. Если нижний уровень ниже предполагаемой позиции слова еще пуст, такое размещение невалидно.
    - **Минимальная высота башни:** чтобы башня считалась завершенной и приносила очки, она должна достигать
      определенного числа уровней (например, минимум 2 или 3 уровня высоты – точное значение зависит от условий
      хакатона). Это предотвращает ситуацию, когда участник сдаёт совсем низкую конструкцию ради малых очков. Стратегия
      должна планировать достичь эту высоту до окончания башни.
    - **Ограничения по размещению слов:** вероятно, существуют дополнительные правила (например, запрет сильных вылетов
      слов за границы основной массы башни, требования к выравниванию), вытекающие из коэффициента пропорциональности. В
      общем, желательно строить башню “равномерно”, без экстремальных навесов или узких шпилей, иначе коэффициент
      пропорций снизит итоговый счет.

- **Подсчет очков и цель стратегии:** За каждый этаж башни начисляются базовые очки (например, количество букв или иное
  значение слов на этом уровне). Итоговые очки башни = сумма базовых очков этажей * коэффициент плотности * коэффициент
  пропорций * коэффициент высоты. **Наша цель** – разработать такую стратегию размещения слов, которая **максимизирует
  эти коэффициенты и базовые очки**. То есть, бот должен использовать по возможности все предоставленные слова,
  выстраивая **валидную** и **эффективную** конструкцию:
    - **Максимум слов:** стараться встроить в башню как можно больше слов из списка (чтобы увеличить сумму очков).
      Неиспользованные слова – это упущенные баллы. Если некоторые слова не подходят, можно попробовать перетасовать
      список (ограниченно) или отложить их, но лучше найти им применение.
    - **Плотная застройка:** располагать слова на каждом уровне плотно, без больших дыр. Идеально – заполнять уровень
      буквами полностью (или почти полностью), достигая высокой плотности заполнения площади.
    - **Хорошие пропорции:** следить, чтобы башня имела достаточно широкое основание и не превращалась в слишком узкую
      “иглу” к вершине. Пропорциональная башня – это примерно равномерная ширина на разных уровнях либо плавное
      уменьшение к верхним этажам. Стратегия не должна, например, строить огромный первый этаж и потом одинокую
      колонну – это дестабилизирует пропорции.
    - **Высота:** стремиться строить как можно выше. Высокая башня (при условии, что она не сверхузкая) даст множитель
      по высоте. Поэтому нужно эффективно использовать слова, чтобы добраться до максимальной возможной высоты, учитывая
      ограничение времени раунда и наличие слов.

- **CLI-инструмент без UI:** программа стратегии будет консольным приложением, без графического интерфейса. Оно
  запускается из командной строки и выводит в консоль ход выполнения (например, логирование действий, отладочную
  информацию). Весь основной функционал (подключение к серверу, расчет хода, отправка запроса) выполняется
  автоматически, без вмешательства пользователя.

- **Переключение между тестовым и основным сервером:** должно легко переключаться. Например, можно сделать флаг `--test`
  для запуска на тестовом стенде `games-test.datsteam.dev` или `--prod` (по умолчанию) для `games.datsteam.dev`. Также
  можно в конфигурационном файле хранить URL или использовать два разных профиля сборки. Это позволит отлаживать
  стратегию безопасно, а затем участвовать в соревновании, просто сменив настройку (при этом *логика стратегии остается
  неизменной*, что важно для надежности).

- **Предопределенная (жестко запрограммированная) стратегия:** от участника требуется реализовать алгоритм принятия
  решений **без использования машинного обучения или случайных проб и ошибок**. Т.е. стратегия должна быть основана на
  детерминированных правилах и алгоритмах, разработанных заранее, опираться на экспертизу, а не на обучение модели. Это
  означает, что наш код явно реализует логику выбора слов и их размещения (эвристики, жадные алгоритмы,
  структурированные решения), которые должны работать хорошо для любого набора слов. Стратегия должна быть достаточно
  продуманной (боевой), чтобы обеспечить высокое качество решений прямо “из коробки”.

- **Код и архитектура:** решение должно быть реализовано на Java. Требуется представить полноценный проект:
    - Четкая структура каталогов и файлов (например, разбиение на пакеты: API-клиент, логика стратегии, модели данных,
      утилиты и т.д.).
    - Полная реализация всех необходимых классов и методов: ничего не остается псевдокодом – каждый компонент реально
      работает.
    - Код снабжен комментариями в важных местах, поясняющими сложную логику (особенно алгоритм стратегии, проверки
      валидности, расчет положений слов).
    - Стиль кодирования чистый и понятный, с упором на поддерживаемость: разумные имена методов и переменных,
      минимизация дублирования, модульность. Это важно, потому что хакатон может потребовать быстрых исправлений или
      улучшений, и чистый код облегчит эти задачи. Кроме того, после победы код может публиковаться, и хотелось бы,
      чтобы он был примером хорошей практики.
    - Решение должно масштабироваться под возможные изменения: например, если увеличится размер поля или добавятся новые
      правила, архитектура должна позволять внести изменения локально, не переписывая всю программу. Это достигается за
      счет правильно выделенных классов и абстракций (например, отдельный модуль работы с API, отделенный от модуля
      логики игры).

Теперь, разобрав требования, перейдем к описанию стратегии и архитектуры решения, удовлетворяющих всем вышеописанным
пунктам.

## Общая стратегия строительства башни

Чтобы эффективно использовать слова и набирать максимум очков, разработаем алгоритм строительства, опирающийся на
принципы **плотной укладки** и **стабильной конструкции**. Ниже описаны ключевые идеи стратегии:

- **Чередующаяся ориентация этажей (аналогично Jenga):** Для устойчивости и плотности мы будем размещать слова на
  чередующихся уровнях в перпендикулярных направлениях. Например, все слова на нулевом (земля) уровне укладываются
  горизонтально вдоль оси X. На следующем уровне (z=1) – вдоль оси Y (перпендикулярно нижним), на третьем снова вдоль X,
  и так далее, чередуя. Такое перекрестное перекрытие напоминает укладку брусьев или игру **Jenga**, где каждый слой
  повёрнут на 90° относительно предыдущего для стабильности. Это помогает связать слои между собой и заполнить пустоты:
  пересекающиеся ориентации позволяют опираться на несколько элементов снизу. В нашей игре слова на одном уровне не
  могут буквально пересекаться с буквами другого (они на разных z), но чередование ориентаций распределяет нагрузку
  равномерно по площади башни. Кроме того, при чередовании проще достичь хороших **пропорций** – башня будет более
  кубической, а не плоской или иглообразной.

- **Формирование широкого основания:** Начнем строить с достаточно широкого основания. На самом нижнем уровне стараемся
  покрыть площадь большим количеством букв. Идеальный случай – полностью заполнить некоторый прямоугольник на земле
  буквами (например, квадрат 5×5 из букв). Поскольку слова – это последовательности букв, полностью заполнить
  прямоугольник без пробелов можно, уложив слова параллельно друг другу, заполняя ряды или колонки:
    - Например, если у нас есть слова подходящих длин, можно уложить их параллельно вдоль X, строка за строкой, образуя
      заполненный блок. Каждый ряд заполняется либо одним длинным словом, либо несколькими более короткими, идущими друг
      за другом без промежутков (см. ниже алгоритм укладки по рядам).
    - Аналогично, на следующем уровне вдоль Y: несколько слов друг за другом по колонкам.
    - Ширину основания выбираем исходя из доступных слов: слишком широко (>10 клеток, к примеру) пытаться покрыть не
      стоит, если слов ограниченное количество. Лучше реально заполнить 5×5 или 6×6 плотно, чем разреженно раскидать по
      10×10. Коэффициент плотности учитывает заполненность – площадь, очерченную словом, должна быть как заполнена
      буквами максимально.

- **Заполнение уровня (укладка слов плотным слоем):** Мы сведем задачу раскладки слов на уровне к задаче упаковки
  отрезков в линию и заполнения нескольких строк:
    - Выбираем целевую ширину заполнения уровня – например, `W` клеток по X (если кладем вдоль X) и `H` строк по Y.
      Тогда целевой областью слоя будет `W x H` прямоугольник.
    - Слова сортируем по длине (количеству букв). Начинаем заполнять слой *построчно* (в текущей ориентации это вдоль X,
      ряд за рядом по Y):
        - Для каждой строки (например, фиксированное `y`), мы последовательно размещаем слова, начиная от левого края (
          x=0) и двигаясь вправо, пока либо не исчерпается ширина W, либо не кончатся слова.
        - На каждой строке стараемся уложить слова так, чтобы суммарная длина слов ≈ W. Если слово точно равно
          оставшемуся месту, кладем его. Если слово длиннее оставшегося места на строке, может быть два подхода:
            1. Либо чуть “недозаполнить” строку (оставить свободный хвост, если он небольшой),
            2. Либо начать новую строку, оставив эту неполной.
        - Предпочтительно, чтобы все строки слоя имели примерно одинаковую длину заполнения, иначе в слое появятся
          “рваные” края, снижающие плотность. Поэтому можно использовать простой жадный алгоритм: **First-Fit Decreasing
          ** – отсортировать слова по убыванию длины, затем заполнять строки по очереди: кладем слово в текущую строку,
          если в ней хватает места, иначе начинаем новую
          строку ([Bin Packing - Shelf Algorithms - Roomanna](https://blog.roomanna.com/09-25-2015/binpacking-shelf#:~:text=The%20simplest%20class%20of%20packing,or%20shelf%29%20as%20possible)).
          Это аналог **shelf алгоритма упаковки**, где каждый ряд – “полка” фиксированной ширины, которую мы заполняем
          максимально.
        - Если слово очень длинное (больше W) и не помещается на выбранную ширину, можно либо увеличить W (если это
          первый слой и позволяет поле 30), либо, если нельзя – такое слово **пропускаем** (или откладываем до другого
          слоя, где ориентация поменяется – возможно вдоль другой оси оно поместится). В крайнем случае, если очень
          длинные слова не вписываются в башню, можно отправить запрос `shuffle` для замены списка (с риском потери
          имеющихся слов).
    - Таким образом, формируется плотный слой слов. Мы намеренно укладываем их плотно (без пробелов между словами на
      строке, если возможно). Даже если между двумя словами останется небольшой зазор (например, не удалось найти слово
      ровно по размеру остатка строки), это не критично – коэффициент плотности немного снизится, но в целом слой будет
      заполнен хорошо.

- **Постепенное сужение к вершине:** По мере строительства вверх возможны две ситуации:
    1. Слова остаются достаточно длинными и многочисленными, чтобы продолжать воспроизводить широкий слой. Тогда можно
       несколько уровней строить одного и того же размера, пока получается заполнять.
    2. Слова становятся короче (например, исчерпали длинные, остались только короткие) или их мало. Тогда продолжать
       делать широкие уровни не получится плотно – будут дыры. Чтобы не терять плотность и пропорции, **сокращаем
       площадь слоя** на более верхних этажах. Проще говоря, башня постепенно сужается, как пирамида или башня замка.
       Например, первые N уровней делаем 6×6, следующие несколько уровней – 4×4, и т.д. При этом каждый следующий “этаж”
       меньшего размера должен располагаться целиком **над** предыдущим, чтобы сохранялась опора: т.е. уменьшаем
       габариты симметрично с краев.

  Стратегия может быть такой: задать несколько целевых размеров уровней – например, на старте W=10 (если слов хватит на
  10×10), после использования длинных слов перейти на W=6, потом на W=3 для финального шпиля. Но это можно и динамически
  решать: если на текущем уровне видим, что доступные слова уже не могут заполнить текущую ширину хотя бы наполовину, то
  пора сузить уровень (начать башню меньшего сечения).

  Таким образом достигается компромисс между высотой и пропорциями: внизу шире (даёт стабильность и плотность), кверху
  уже (даёт возможность достроить высоту имеющимися словами, не распыляя их по слишком большой площади).

- **Использование всех слов и перетасовка:** В идеале, хотим встроить **каждое слово** из списка в башню, чтобы его очки
  не пропали зря. Поэтому стратегия старается найти место даже для неудобных слов. Например, если осталось короткое
  слово, которое не вписывается в плотный слой, его можно положить сверху в виде шпиля (даже если одиноко торчит, это
  даст высоту + использует слово, пусть с небольшим влиянием на плотность). Если осталось длинное слово, для которого
  уже нет достаточного места на сужающихся уровнях – возможно, башню лучше **завершить** и потом начать новую (где этот
  слово ляжет на первом уровне). Либо выполнить `shuffle`, но учитывая ограниченность
  `shuffleLeft` ([openapi.yml](file://file-EqgpUPnpFmazNzc9qFuQue#:~:text=example%3A%202023,example%3A%201%20usedIndexes%3A%20type%3A%20array)) ([openapi.yml](file://file-EqgpUPnpFmazNzc9qFuQue#:~:text=properties%3A%20shuffleLeft%3A%20type%3A%20integer%20example%3A,word2)),
  это крайний случай – применять, если в текущем наборе слишком много непригодных слов (например, очень длинные, не
  вмещающиеся в 30×30, или набор сплошь неудобных коротких, хотя короткие можно всегда пристроить). В общем, *
  *перетасовка** рациональна на ранних этапах башни, если видим, что из данного списка тяжело строить (например, совсем
  нет длинных слов для основания или все слова слишком длинные для поля). Если же башня уже частично построена, лучше
  избегать shuffle (так как неиспользованные слова пропадут).

- **Завершение башни (done):** Нужно вовремя подать сигнал завершения (`done=true` в запросе `/api/build`), чтобы башня
  зафиксировалась и принесла
  очки ([openapi.yml](file://file-EqgpUPnpFmazNzc9qFuQue#:~:text=summary%3A%20,you%20can%20start%20new%20tower)). Когда
  завершать:
    - Если текущий раунд близок к окончанию (например, осталось меньше времени, чем нужно на еще один ход), нужно
      завершить, иначе рискуем не успеть получить очки.
    - Если слова закончились или остались те, что нельзя уложить без потери качества – лучше завершить и получить
      максимум за что построено, чем тянуть время. После завершения, на следующем ходу мы получим новый список слов и
      сможем начать новую башню, то есть продолжим набирать очки.
    - Также, если башня уже очень высокая и дальнейшее увеличение дает мизерный прирост (например, остались только 1-2
      буквы, которые сильно снизят плотность верхушки, ухудшив коэффициенты больше, чем добавят высоты), то имеет смысл
      остановиться.

  Наша стратегия, таким образом, строит башню до тех пор, пока это эффективно, а затем закрывает ее. За время раунда
  можно успеть построить несколько башен подряд, если они относительно небольшие, либо одну-две очень больших. Это
  зависит от темпа поступления слов и времени. Мы будем стремиться к *качеству*, а не количеству башен: лучше несколько
  высоких и плотных башен, чем много мелких.

Резюмируя, алгоритм можно представить так:

1. **Начало новой башни:** определить оптимальный размер основания на основе текущего списка слов (например, оценить
   среднюю/максимальную длину слов). Подготовить план уровня: список рядов и требуемую ширину заполнения.
2. **Цикл по уровням (этажам):**
    - Получить доступные слова (если первый ход башни – берем из `GET /api/words`, если продолжение – берем оставшиеся с
      прошлого хода из локального хранилища или снова из API, где они помечены в `usedIndexes`).
    - Выбрать ориентацию (чередуем по номеру уровня).
    - Уложить слова текущего уровня по алгоритму заполнения (жадно заполняя ряды).
    - Отметить использованные слова как использованные. Обновить внутреннее представление башни (занятые клетки).
    - Проверить коэффициенты/критерии: достаточно ли плотен текущий слой? Остались ли слова для продолжения? Хватает ли
      поддержка снизу для продолжения (вдруг сделали нависающий край – хотя стратегия этого избегает)? Не вышли ли за
      границы? Если что-то не так, можно откатить последние слово/уровень и попробовать по-другому (например, если слой
      получился слишком пустым – решаем завершать башню или сузить слой).
    - Если продолжаем строить: формируем команду `build` с координатами всех слов текущего уровня и отправляем на
      сервер (тем самым фиксируя их размещение в игре). Далее ждем следующий ход.
    - Если решили завершать: формируем последний запрос `build` с `done=true`, включая оставшиеся слова (если есть
      подходящие, можно даже все оставшиеся попытаться куда-то воткнуть на финальном шаге, либо просто завершить без их
      использования). После этого сервер сохранит башню, начислит очки, а мы со следующего хода начнем новую башню с
      новым списком слов.
3. **Новая башня (при наличии времени):** повторяем процесс с новым списком.

При этом важно на каждом ходу учитывать **время**: если укладка уровня заняла, скажем, 2 секунды вычислений, у нас еще
есть время запросить, например, `GET /api/towers` или обновить данные, но не стоит приближаться к 60 секундам. Обычно,
наш алгоритм достаточно быстрый (длина списка слов не огромна, перебор и сортировка займут миллисекунды), поэтому он
многократно уложится в 60с.

Далее рассмотрим, как данная стратегия будет реализована в коде Java, разберем архитектуру проекта, основные классы и
методы.

## Архитектура Java-проекта

Проект организован по классическому принципу разделения ответственности:

- **Client/API слой** – отвечает за соединение с сервером и вызов REST API методов.
- **Model/Entity слой** – представляет основные сущности игры в виде Java-классов (например, Слово, Башня, Этаж, Ответы
  API).
- **Strategy/Logic слой** – собственно алгоритм выбора действий: анализ данных и решение, какие слова куда ставить.
- **Main (CLI) слой** – точка входа, парсинг аргументов, запуск цикла игры, вывод логов.

Такое разделение сделает код чище: можно тестировать стратегию отдельно, подавая ей фиктивные списки слов, можно
отлаживать API отдельно.

Ниже приведена предлагаемая структура пакетов и классов (именование на английском для кода, согласно Java conventions,
комментарии – по-русски или английски для пояснений):

```
src/main/java/
    dev/datscity/client/
        GameApiClient.java      // класс для обращения к REST API (выполнение HTTP запросов)
        ApiException.java       // класс-исключение на случай ошибок API
    dev/datscity/model/
        Word.java               // класс, представляющий слово (свойства: текст, длина, возможно индекс и пр.)
        WordPlacement.java      // класс для размещения слова: содержит ссылку на Word + координаты (x,y,z) + dir
        TowerMap.java           // класс, представляющий текущую башню/карту занятых клеток (например, 3D-массив или сет)
        ApiResponses.java       // вложенные статические классы/структуры для парсинга JSON ответов (WordsResponse, TowersResponse, RoundInfo и т.д.)
    dev/datscity/strategy/
        TowerBuilderStrategy.java   // основной класс стратегии строительства башни
        LevelPlanner.java           // вспомогательный класс/модуль, умеющий планировать размещение слов на одном уровне (алгоритм укладки)
    dev/datscity/
        Main.java               // главный класс с методом main(), запускающий бота
```

Разберем роли этих компонентов и их взаимосвязи.

### 1. Компонент API-клиента

**GameApiClient** – инкапсулирует взаимодействие с сервером. Он хранит базовый URL (в зависимости от режима тест/боевой)
и токен авторизации. Предоставляет методы, соответствующие игровым действиям:

- `List<String> getWords()` – запрос списка слов. Возвращает список строк (или сразу список объектов `Word`) текущего
  хода. Также может возвращать доп. данные: оставшиеся shuffle, время до следующего хода и т.д. В реализации мы парсим
  JSON ответ
  `PlayerExtendedWordsResponse` ([openapi.yml](file://file-EqgpUPnpFmazNzc9qFuQue#:~:text=turn%3A%20type%3A%20integer%20example%3A%201,2)) ([openapi.yml](file://file-EqgpUPnpFmazNzc9qFuQue#:~:text=type%3A%20integer%20words%3A%20type%3A%20array,word3%20items%3A%20type%3A%20string)).
- `void shuffleWords()` – запрос на перетасовку. Выполняет `POST /api/shuffle`, парсит новый список слов (обновляет
  внутреннее состояние списка слов в стратегии).
- `TowerState getTowers()` – запрос состояния башен (`GET /api/towers`), возвращает объект с информацией о текущей
  строящейся башне (если есть) и списком завершенных (с их
  очками) ([openapi.yml](file://file-EqgpUPnpFmazNzc9qFuQue#:~:text=doneTowers%3A%20type%3A%20array%20items%3A%20%24ref%3A,components%2Fschemas%2Fmodel.PlayerTowerResponse)).
  Можно вызывать периодически для отслеживания прогресса, хотя не обязателен каждый ход.
- `RoundInfo getRoundInfo()` – `GET /api/rounds`, чтобы узнать, активен ли раунд, сколько осталось времени. Может
  вызываться раз в минуту или при старте.
- `void sendBuild(List<WordPlacement> placements, boolean done)` – самый важный метод: отправляет ход строительства. Ему
  передается список слов с координатами и флаг done. Внутри он формирует JSON тело запроса по форме
  `PlayerBuildRequest` – массив объектов, каждый с полями `id` (индекс слова в текущем списке), `pos` (тройка
  координат), `dir` (
  ориентация) ([openapi.yml](file://file-EqgpUPnpFmazNzc9qFuQue#:~:text=properties%3A%20dir%3A%20type%3A%20integer%20example%3A,0%20pos%3A%20type%3A%20array%20example)),
  плюс флаг `done`. Отправляет `POST /api/build`. В ответ сервер пришлет обновленный список слов (который мы можем сразу
  же сохранить для следующего
  хода) ([openapi.yml](file://file-EqgpUPnpFmazNzc9qFuQue#:~:text=,description%3A%20Bad%20Request%20content)) ([openapi.yml](file://file-EqgpUPnpFmazNzc9qFuQue#:~:text=type%3A%20string%20example%3A%20word%20model,type%3A%20integer%20example%3A%203%20words)).
  Если башня завершена, текущая башня сбрасывается, и список слов наверняка новый для следующей башни.

GameApiClient может быть реализован с помощью стандартных библиотек:

- Используем `java.net.HttpURLConnection` или `java.net.http.HttpClient` (Java 11+) для выполнения запросов. Например,
  `HttpClient.newHttpClient().send(request, BodyHandlers.ofString())` для простоты.
- Для парсинга JSON можно задействовать библиотеку Jackson или Gson, либо использовать org.json. Чтобы не привязываться
  к внешним либам, можно вручную распарсить самые нужные поля (т.к. формат довольно простой). Но лучше модельные классы
  и Jackson – так код чище.
- Этот класс также будет отвечать за вывод debug-информации о запросах/ответах, если включен verbose режим.

**ApiResponses/модели ответов:** Можно определить внутренние классы, соответствующие структурам JSON. Например:

```java
class ApiResponses {
    static class WordsResponse {
        public List<String> words;
        public int turn;
        public int shuffleLeft;
        // ... другие поля как nextTurnSec, roundEndsAt, etc.
    }

    static class TowersResponse {
        static class Tower {
            public double score;
            public List<PlayerWord> words;
        }

        static class DoneTower {
            public int id;
            public double score;
        }

        public List<DoneTower> doneTowers;
        public double score;  // общий счет?
        public Tower tower;   // текущая башня
    }
    // и т.д. для RoundInfo, PlayerWord, etc.
}
```

Эти структуры облегчат автоматическое преобразование JSON через Jackson (просто
`objectMapper.readValue(body, WordsResponse.class)`).

### 2. Модели и представление игрового состояния

**Word** – класс для слова. Содержит:

- `String text` – собственно слово.
- `int length` – длина (можно вычислять как `text.length()`, но сохранить для удобства и эффективности).
- Возможно, `int index` – индекс слова в текущем списке (тот, который нужен для отправки хода в TowerWordRequest.id).
  Это важно: сервер идентифицирует слово по индексу в списке, а не по самому
  тексту ([openapi.yml](file://file-EqgpUPnpFmazNzc9qFuQue#:~:text=properties%3A%20dir%3A%20type%3A%20integer%20example%3A,0%20pos%3A%20type%3A%20array%20example)).
  Индексы, судя по `usedIndexes`, могут меняться при shuffle или новом списке, поэтому будем внимательно обновлять.
- Можно также хранить какие-то оценочные свойства (например, ценность слова, если известно, что длиннее = ценнее, или
  если слова имеют разные очки не только от длины).

**WordPlacement** – класс, описывающий решение по размещению одного слова:

- `Word word` – ссылка на слово (или хотя бы его индекс и текст).
- `int x, y, z` – координаты размещения начала слова.
- `int dir` – ориентация (0 или 1).
- Возможно, `int index` – дублируем индекс (для удобства, хотя можно взять из `word`).

  Этот класс используется в стратегии для планирования: стратегия выдает список WordPlacement, которые нужно отправить
  на сервер.

**TowerMap** – класс, представляющий текущую башню и занятые клетки. Поскольку нам нужно проверять пересечения и
поддержку, удобно вести структуру данных для быстрого ответа на запрос: “занята ли клетка (x,y,z)” и “что находится под
клеткой (x,y,z)”. Реализация:

- Можно использовать трёхмерный массив boolean `[X][Y][Z]` размером [30][30][100] – память позволяет (90k boolean ~ 90k
  bytes).
- Или использовать `Set<Cell>` где `Cell` – структурка с x,y,z, для занятых позиций. Но Set операций может быть чуть
  медленнее, хотя для <100k элементов это не проблема.
- Либо три* 2D массива для слоев, но проще один 3D.

Храним также:

- текущую высоту башни (max z заполненный + 1).
- возможно, список уровней, где уровень – коллекция WordPlacement (слова, лежащие на этом уровне), чтобы можно было
  анализировать плотность/покрытие каждого этажа.

**TowerMap** предоставляет методы:

- `boolean canPlaceWord(Word word, int x, int y, int z, int dir)` – проверка валидности размещения данного слова на
  позиции:
    - Проверить границы: если dir=0 (вдоль X), то `x + word.length - 1 < width (30)`; если dir=1, то
      `y + word.length - 1 < depth (30)`. Координаты >=0.
    - Проверить, что все клетки [x..x+L-1][y][z] (при dir=0) или [x][y..y+L-1][z] (при dir=1) свободны (не заняты в
      `TowerMap`).
    - Если z > 0: для каждой такой клетки проверить `TowerMap.isOccupied(x, y, z-1)` – должна быть `true` (опора есть).
      Если хотя бы под одной буквой снизу пусто, то слово нельзя ставить (частично нависать не разрешаем).
    - (Если правила допускают частичную опору – например, хотя бы половина букв должна опираться – их нет в явном виде,
      так что требуем полной опоры).
- `void placeWord(Word word, int x, int y, int z, int dir)` – добавить слово в башню (занять соответствующие клетки,
  обновить высоту). Перед вызовом предполагается, что **canPlaceWord** уже вернул true.
- `double computeDensity(int z)` – (опционально) расчет плотности заполнения заданного уровня z. Например, можно
  вычислить количество занятых клеток на этом уровне и разделить на площадь минимального прямоугольника, их
  охватывающего. Это пригодится, чтобы оценивать эффективность укладки уровня и решать, надо ли сузить башню.
- `int getCurrentHeight()` – возвращает текущее количество уровней (высота).
- `clone()` или методы для копирования – возможно пригодится, если стратегия хочет смоделировать “что если поставить так
  или этак” и откатиться.

### 3. Класс TowerBuilderStrategy (логика стратегии)

Это основной класс, реализующий алгоритм, описанный в разделе стратегии. Его задача – на каждом ходу, исходя из текущего
состояния (список доступных слов, текущая башня), выбрать оптимальное действие:

- Если нет активной башни (только что начали новую или после done): инициализировать TowerMap, планировать основание.
- Если башня строится: решить, что делать на текущем шаге – продолжать выкладывать следующий уровень или завершать.

Основные методы:

- `void startNewTower(List<Word> wordsList)` – инициализировать новую башню. Тут стоит определить, какой будет
  первоначальный размер слоя:
    - Например, оценить среднюю длину слов: если много длинных (>10 букв) – можно позволить широкий слой (8-10). Если
      слова в основном короткие (3-5 букв) – широкую площадь ими не заполнить, лучше сразу ограничиться меньшим
      размером (например 5).
    - Можно взять максимум длины или 90-й перцентиль длины как W для первого слоя. Или просто начать с 30 и потом
      увидев, что не заполняется, сузить – но лучше заранее, чтобы не делать лишнюю работу.
    - Создаем новый TowerMap (пустой).
    - Определяем `currentLayerWidth` (например W=...).
    - Готовим списки для размещения.
- `List<WordPlacement> planNextMove(List<Word> words)` – основная логика хода. На входе – актуальный список доступных
  слов (неиспользованных). Возвращает список WordPlacement, которые нужно отправить на сервер в этом ходу, **и** может
  устанавливать флаг завершения.

  Внутри:
    - Проверяем, строим ли мы новый уровень или завершаем:
        - Если минимальная высота не достигнута, точно строим дальше.
        - Иначе, смотрим сколько слов осталось и какие коэффициенты ожидаются.
    - Если решили строить уровень:
        - Определяем ориентацию: `dir = (currentLevel % 2 == 0 ? 0 : 1)` допустим (0 – вдоль X, 1 – вдоль Y).
        - Вызываем LevelPlanner (или пишем прямо тут) для укладки слов на `currentLayerWidth x currentLayerDepth`
          область. Например, текущая запланированная ширина = `layerSize` (квадрат layerSize x layerSize, или
          прямоугольник W x H). Если мы решили чередовать квадратами, то можно держать один размер для X и Y (т.е. слой
          всегда layerSize x layerSize). Или можно отдельно ширину по X и по Y. Но для простоты предположим квадратные
          слои.
        - **LevelPlanner**: принимает список слов и размеры, возвращает список WordPlacement для заполнения одного
          уровня:
            * Сортирует слова по длине (desc).
            * Итерируется по строкам (например, y from 0 to H-1, for orientation X):
                + xStart = 0.
                + Для каждого слова в списке (в порядке): если word.length <= (layerSize - xStart) – помещаем это слово
                  в координаты (xStart, currentY, currentZ), dir=0, добавляем в placements, увеличиваем xStart +=
                  word.length.
                + Удаляем слово из списка доступных (или помечаем использованным).
                + Продолжаем, пока xStart < layerSize и есть слова. Если слово не влезло, переходим к следующему слову (
                  или заканчиваем строку, как вариант Next Fit: закончили строку и сразу выход, но мы хотим заполнить по
                  максимуму, можно сменить слово).
                + Если достигли layerSize (заполнили строку полностью) или не осталось слов, переходим на next строку (
                  y++) и повторяем.
            * Таким образом, получим заполнение несколько строк. Если остались незаполненные строки (не хватило слов) –
              слой не полный, но это ок, мы сколько смогли.
            * Можно также оптимизировать подбор слов к строкам: например, если остаток пространства < минимальной длины
              оставшихся слов, то уже невозможно заполнить далее эту строку – тогда перейдем на новую строку, оставив
              пространство пустым (иначе мы в бесконечном цикле).
            * **Примечание:** Этот алгоритм жадный и может не идеально заполнить все пробелы. Существуют более сложные
              алгоритмы (бин-пакер, перебор комбинаций для каждой строки), но учитывая ограниченное время хода, жадного
              подхода достаточно и надежно (а небольшие пустоты допустимы).
        - Получив список WordPlacement для слоя, проверяем каждое через `TowerMap.canPlaceWord`:
            * Теоретически LevelPlanner уже следил за границами, и поскольку слой новый, там не должно быть пересечений
              на этом же уровне (мы специально не перекрещиваем слова, только последовательное размещение). Также
              поддержка снизу гарантирована, если предыдущий слой был >= текущего по площади (поскольку мы сужаем или
              равны).
            * Но на практике, если мы сужаем башню (делаем слой меньше, чем предыдущий), надо убедиться, что все клетки,
              на которые ставим буквы, имеют поддержку снизу. Например, предыдущий слой был 6×6 заполнен, а мы решили
              сделать слой 4×4 по центру: убедимся, что смещаем этот слой так, чтобы он был над заполненной частью.
              Иначе если поставить край нового слоя над пустым местом прошлого уровня – нарушится поддержка. **Решение:
              ** при сужении, всегда центрировать новый слой относительно предыдущего. Например, если предыдущий слой
              занимал X from 0..5 и Y from 0..5, а новый слой 4×4, то сместим его координаты, скажем, начиная с x=1,y=1
              до x=4,y=4 – тогда он лежит ровно сверху. В стратегии можно хранить `offsetX, offsetY` для текущего слоя,
              которые обычно 0,0 для равного размера, а для суженных – >0. В простейшем случае, если всегда начинали с
              0,0, при сужении можно тоже начинать с 0,0 (т.е. он будет в углу) – но тогда 2 клетки слоя окажутся над
              пустотой. Поэтому лучше сдвиг.
            * Мы учтем это: если `layerSize` уменьшился по сравнению с прошлым, установим
              `offsetX = (prevLayerSize - layerSize)/2` (округлив вниз), `offsetY` аналогично, и уложим слова с таким
              смещением (LevelPlanner нужно знать offset, чтобы начинать с x=offset а не 0, и ограничить до
              offset+layerSize).
            * Это гарантирует новую платформу по центру старой, максимизируя поддержку.
        - Обновляем TowerMap, занося все новые слова.
        - Оцениваем плотность получившегося слоя. Можно посчитать заполненные клетки vs (layerSize*layerSize). Если
          плотность слишком низкая (например <50%), возможно стоит не продолжать строить вверх (потому что tower уже
          сильно разрежена) – может, завершить.
        - Увеличиваем счётчик текущего уровня (currentLevel++).
        - Возвращаем список WordPlacement (и флаг done=false).
    - Если решили **завершать башню** на этом ходу:
        - Можем дополнительно попробовать использовать оставшиеся слова прямо сейчас:
            * Например, остались 1-2 слова, которые не вошли – если есть возможность, можно попытаться их куда-то
              приткнуть: либо сделать еще один маленький уровень, либо даже положить их на уже существующие уровни, если
              есть место (но это сложно – лучше не нарушать построенное).
            * Чаще всего на момент решения завершить уже все пригодные слова использованы, остаются только неудобные –
              их можно отбросить.
        - Формируем пустой список WordPlacement (или список последних слов, если решили их размещать) и устанавливаем
          флаг done=true.
        - После отправки этого хода, `GameApiClient.sendBuild(..., true)` вернет новый список слов для следующей башни,
          и мы вызовем `startNewTower` в следующем цикле.

- `void onRoundEnd()` – необязательный метод, который можно вызвать, если получили сигнал об окончании раунда (например,
  из RoundInfo статус). Он может вывести статистику, сохранить результаты, сбросить что-то или просто остановить цикл
  игры.

**LevelPlanner** – как описано, может быть реализован как отдельный класс или внутри TowerBuilderStrategy. Его задача –
взять текущий список слов и уложить их на заданную область. Можно сделать его статическим методом, принимающим
параметры (слова, width, height, offsetX, offsetY, orientation) и возвращающим список размещений.

### 4. Главный цикл и запуск (Main)

**Main** – класс с `public static void main(String[] args)`. Его обязанности:

- Разобрать аргументы командной строки. Например, использовать `args` чтобы понять URL и токен:
    - `--test` переключает на тестовый URL.
    - Возможно, `--token <token>` для указания токена (либо взять из переменной окружения, либо запросить ввод у
      пользователя).
    - Можно также задать verbosity, параметры стратегии (например, размеры слоёв по умолчанию).
- Создать экземпляр `GameApiClient` с нужным URL и токеном.
- Создать экземпляр `TowerBuilderStrategy`.
- Основной цикл игры:
  ```java
  while (true) {
      // 1. Получаем актуальный список слов и информацию о ходе
      WordsResponse resp = api.getWords();
      List<Word> words = Word.fromStrings(resp.words);  // преобразуем в объекты Word с длинами и индексами
      // 2. Если новый ход, проверяем надо ли инициализировать новую башню
      if (resp.turn == 1 || strategy.isTowerCompleted()) {
          strategy.startNewTower(words);
      }
      // 3. Решаем, какие действия сделать на этом ходу
      List<WordPlacement> move = strategy.planNextMove(words);
      boolean done = strategy.isFinishing();  // или стратегия может вернуть флаг окончания вместе с ходом
      // 4. Отправляем действие на сервер
      api.sendBuild(move, done);
      // 5. Если башня завершена, можно сразу вызывать api.getTowers() для получения очков или перейти к следующему ходу, где придет новый список слов.
      // 6. Проверяем окончание раунда
      if (resp.roundEndsAt != null && timeNow() >= resp.roundEndsAt) {
          break; // выход из цикла если игра окончена
      }
      // 7. Цикл повторяется каждую минуту по ходу
  }
  ```
  Обратите внимание: можно не делать `Thread.sleep(60000)`, так как `api.getWords()` вероятно блокирует до начала
  следующего хода или возвращает nextTurnSec. Но в данных есть
  `nextTurnSec` ([openapi.yml](file://file-EqgpUPnpFmazNzc9qFuQue#:~:text=type%3A%20array%20nextTurnSec%3A%20type%3A%20integer,shuffleLeft%3A%20type%3A%20integer%20example%3A%203)) –
  время до следующего хода. Мы можем сделать `Thread.sleep(resp.nextTurnSec * 1000)` после отправки хода, чтобы не
  спамить сервер. Или, лучше, организовать ожидание события. Но для простоты сна достаточно, т.к. ход ровно 60 сек.

  Также, `resp.turn` поможет понять, новый ли это раунд (если turn сбросился на 1).
- Отлов исключений: если `ApiException` случится (например, запрос не удался, или сервер вернул ошибку 400), нужно
  залогировать и либо продолжить (попробовать снова), либо прекратить. В хакатоне лучше попытаться восстановиться.
- По завершению раунда (выход из цикла) – вывести финальный счет. Можно вызвать `api.getTowers()` и суммировать очки или
  вывести список doneTowers.

Главный цикл фактически управляется сервером через данные, но мы по сути опрашиваем его.

### Пример работы стратегии

Рассмотрим небольшой пример, чтобы проиллюстрировать работу нашего решения:

**Предположения примера:** карта 10×10 (для простоты),
слова: ["DATA", "CITY", "TEAM", "HACK", "JAVA", "CODE", "CUP", "AI"]. Допустим, все слова длиной 3-5.

- **Ход 1:** Получив список слов, стратегия решает сделать основание 5×5. Ориентация гориз. (X). Сортируем слова по
  длине: ["CITY"(4), "TEAM"(4), "DATA"(4), "HACK"(4), "JAVA"(4), "CODE"(4), "CUP"(3), "AI"(2)]. Заполняем слой y=0..4:
    - y=0: кладем "CITY"(4) с x=0..3, затем остается 1 клетка до 5 – ни одно слово длиной ≤1 нет, строка заполнена на
      80%.
    - y=1: кладем "TEAM"(4) x=0..3, аналогично остаток 1.
    - y=2: "DATA"(4) x=0..3.
    - y=3: "HACK"(4) x=0..3.
    - y=4: "JAVA"(4) x=0..3.
      Осталось слов: ["CODE", "CUP", "AI"]. Слой 5×5 заполнен на 80% (плотность 0.8). Все слова уложены валидно (земля,
      не пересекаются).
      Отправляем /api/build с 5 словами (CITY,...,JAVA) координаты и dir=0, done=false.
- **Ход 2:** Получаем оставшиеся слова ["CODE"(4), "CUP"(3), "AI"(2)] + возможно новые, если сервер выдал новые после
  размещения? Предположим, сервер сразу не пополняет, осталось только эти (а shuffle мы не делали). Теперь уровень 2 (
  z=1, ориентация вертик. Y). База 5×5 уже есть, но слов мало – возможно стоит сузить до 3×3, чтобы хватило. Стратегия
  видит осталось 3 слова суммарно 9 букв, 5×5=25 клеток не заполнить, решает сузить до 3×3. Устанавливаем offsetX=1,
  offsetY=1, layerSize=3.
  Заполняем слой (dir=1, вдоль Y, между x=1..3, y=1..3):
    - x=1 (col 1 within offsetX..offsetX+2=1..3): кладем "CODE"(4) вдоль Y от y=1..4 – оops, длина 4 не влезает в 3 (max
      y=3) *в пределах слоя*. Значит "CODE" не помещается в слой 3 – пропускаем его или решаем, что suzili слишком
      сильно. Можно либо отложить "CODE" на новый башню, либо все же строить 5×5 второй уровень? Но 3 слова на 5×5 будет
      пусто (60%). Возможно лучше сделать 4×4 вместо 3×3. Предположим стратегия решает 4×4. offset=0.5 ~ 0 (мы по
      целому, оставим 0 для простоты).
    - Заново: layerSize=4 (x=0..3, y=0..3), dir=1.
    - x=0: кладем "CODE"(4) от y=0..3 (полностью заполнили колонку 0).
    - x=1: кладем "CUP"(3) от y=0..2, осталось 1 клетка (y=3) пустая в этой колонке.
    - x=2: кладем "AI"(2) от y=0..1, колонка заполнена наполовину, места осталось.
    - x=3: нет слов осталось, колонка пустая.
      Слой 4x4 заполнен не полностью (~ maybe 9/16 = 56%). Не очень плотный, но хоть что-то. Все размещения опираются на
      нижний слой? Нижний слой был 5x5, этот 4x4 лежит на области x=0..2,y=0..3 – под большинством букв есть опора,
      кроме, возможно, буквы "AI" на (x=2,y=2..3)? Если "AI" y=0..1 at x=2, z=1, под ними z=0 x=2,y=0..1 – были слова "
      CITY","TEAM"? Actually city filled x=0..3,y=0; team x=0..3,y=1 – так y=0..1 at x=2 both have support. "CUP" at
      x=1,y=0..2, under y=2,x=1 support? y=2,x=1 z=0 was "DATA"? Yes data x=0..3,y=2 covers x=1,y=2. Good. "CODE"
      x=0,y=0..3, under those positions at z=0: x=0,y=0..3 were all filled by five words at y=0..3 (the first letters of
      each row likely). So support exists.
      Отправляем эти 3 слова. Остальных нет – башня построена 2 уровня.
      Однако башня высотой 2, возможно минимальная высота >2? Скажем требовали ≥3 уровней. У нас нет слов, но можно
      попросить shuffle или начать новую башню. Если высоты не хватает, можно было заранее не завершать – но слов
      кончились.
      В такой ситуации стратегия могла: лучше завершить с 2 уровнями (если это допустимо) и начать новую с новым
      списком, чем ждать.
      Если 2 недостаточно, надо было shuffle до размещения, но допустим достаточно.
- **Ход 3:** После done башня завершена, сервер вернул новый набор слов. Стратегия начинает новую башню... и так далее.

Это упрощенный пример, но он показывает, как стратегия укладывает слова, принимает решение о сужении и завершении.

### Важные детали реализации

- **Управление индексами слов:** В каждом ответе `words` – это массив строк. Их позиция в массиве и есть индекс для
  использования в `/api/build`. Когда мы используем слово, нам нужно передать его индекс. Важно: после каждого хода
  список может меняться (удаленные слова убираются или заменяются). В `PlayerExtendedWordsResponse` есть поле
  `usedIndexes` ([openapi.yml](file://file-EqgpUPnpFmazNzc9qFuQue#:~:text=example%3A%201%20usedIndexes%3A%20type%3A%20array,2%20items%3A%20type%3A%20integer)) –
  вероятно, индексы уже использованных слов. Сервер мог либо просто отметить их (и не убирать из списка), либо убрать.
  Нам нужно быть внимательными: проще всего завести список `currentWords = List<Word>` и обновлять его после каждого
  хода:
    - После `getWords()` сохраняем список.
    - Когда планируем ход, берем объекты Word и определяем их индекс как `currentWords.indexOf(word)` – но это O(n).
      Лучше в Word хранить `index` сразу, привязанный к текущему списку.
    - После отправки build, если ответ
      `PlayerWordsResponse` ([openapi.yml](file://file-EqgpUPnpFmazNzc9qFuQue#:~:text=model,3%20words%3A%20type%3A%20array%20example))
      пришел с новым списком (возможно с удаленными использованными): обновляем currentWords.
    - Если башня не завершена (done=false), возможно, использованные слова просто пометились, но не выдали новых –
      тогда, может, сервер возвращает тот же список и usedIndexes. В таком случае мы можем сами удалить из currentWords
      те слова, что отправили (или пометить их, например, null).
    - Если башня завершена (done=true), скорее всего, придет полностью новый список слов (для новой башни).
    - Обязательно сбрасывать индексы при новом списке.

- **Отладка и логирование:** Добавим достаточное логирование: например:
    - Лог старт раунда, конец раунда.
    - Каждый ход: оставшееся время, сколько слов доступно, какие слова выбраны для размещения и их координаты.
    - Если произошел shuffle: лог, сколько осталось попыток `shuffleLeft`.
    - Если завершили башню: лог итогов (вызвав `getTowers()` или используя сразу ответ от /api/build, который мог бы
      вернуть часть информации).

  Это поможет и на этапе разработки, и при демонстрации жюри.

- **Обработка ошибок API:** Если, например, `build` вернул 400 Bad Request, значит мы, возможно, предложили невалидное
  размещение (пропустили какую-то проверку). Стратегия на ходу может:
    - Проанализировать сообщение об ошибке (в
      `gamesdk.PublicError.message` ([openapi.yml](file://file-EqgpUPnpFmazNzc9qFuQue#:~:text=code%3A%20type%3A%20integer%20message%3A%20type%3A,DoneTowerResponse%3A%20type%3A%20object%20properties%3A%20id))).
    - Если, скажем, написано "word intersects" – мы пропустили пересечение, надо исправить TowerMap логику.
    - Если "unsupported placement" – значит поддержка нарушена, скорректировать.
    - Можно на всякий случай реализовать небольшую коррекцию: перед отправкой финально еще раз прогнать `canPlaceWord`
      для каждого WordPlacement и убедиться в валидности.
    - При ошибке, можно попробовать уменьшить слой или завершить башню досрочно как fallback, чтобы не пропустить ход
      совсем. (Но лучше довести алгоритм до корректности).

- **Кэширование и локальное хранение состояния:** Стратегия будет хранить `TowerMap` и список оставшихся слов в памяти
  между ходами. Это необходимо, так как сервер хранит только, что уже размещено (в `GET /api/towers` можно получить
  текущие слова и их
  позиции ([openapi.yml](file://file-EqgpUPnpFmazNzc9qFuQue#:~:text=score%3A%20type%3A%20number%20example%3A%201,PlayerWord%3A%20type%3A%20object%20properties)),
  но мы можем сами поддерживать копию вместо опроса). Чтобы не зависеть от сетевых задержек, проще обновлять свой
  `TowerMap` при каждом успешном размещении, чем каждый раз дергать /api/towers. Однако, можно периодически сверять, нет
  ли расхождений, но если код верен, их не будет.

- **Конфигурация:** Можно сделать properties файл или несколько констант в коде, чтобы легко менять, например, *
  *initialLayerSize**, **minDensityThreshold** (минимально допустимая плотность, ниже которой завершаем башню), *
  *minHeight** (минимальная высота для done), **maxShuffle** (при каком условии делать shuffle). Эти параметры стратегии
  позволяют тонко настроить поведение. Во время хакатона, протестировав на тестовом сервере, участник может подправить
  параметры для лучшего результата.

## Заключение

Проект, спроектированный по указанным принципам, представляет собой законченный Java-приложение, способное автономно
играть в DatsCity, строя башни из слов. Мы подробно рассмотрели требуемую функциональность и предложили:

- Структуру кода с разделением обязанностей (API, модель, стратегия, main).
- Алгоритм стратегии, уделяющий внимание игровым метрикам (плотность, пропорции, высота) и эффективно использующий
  слова.
- Детали реализации ключевых моментов: укладка слов на уровне, проверка правил, взаимодействие с сервером.
